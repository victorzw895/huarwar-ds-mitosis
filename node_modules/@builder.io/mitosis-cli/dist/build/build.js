"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
var mitosis_1 = require("@builder.io/mitosis");
var debug_1 = __importDefault(require("debug"));
var function_1 = require("fp-ts/lib/function");
var fs_extra_1 = require("fs-extra");
var lodash_1 = require("lodash");
var fast_clone_1 = require("../helpers/fast-clone");
var context_1 = require("./helpers/context");
var files_1 = require("./helpers/files");
var overrides_1 = require("./helpers/overrides");
var transpile_1 = require("./helpers/transpile");
var cwd = process.cwd();
/**
 * This provides the default path for a target's contents, both in the input and output directories.
 */
var getTargetPath = function (_a) {
    var target = _a.target;
    switch (target) {
        default:
            return (0, lodash_1.kebabCase)(target);
    }
};
var DEFAULT_CONFIG = {
    targets: [],
    dest: 'output',
    files: 'src/*',
    overridesDir: 'overrides',
    getTargetPath: getTargetPath,
    options: {},
};
var getOptions = function (config) {
    var _a, _b;
    var newConfig = __assign(__assign(__assign({}, DEFAULT_CONFIG), config), { options: __assign(__assign({}, DEFAULT_CONFIG.options), config === null || config === void 0 ? void 0 : config.options), generators: Object.assign(mitosis_1.targets, config === null || config === void 0 ? void 0 : config.generators) });
    /**
     * Apply common options to all targets
     */
    if (newConfig.commonOptions) {
        for (var _i = 0, _c = newConfig.targets || []; _i < _c.length; _i++) {
            var target = _c[_i];
            newConfig.options[target] = __assign(__assign(__assign({}, newConfig.commonOptions), newConfig.options[target]), { plugins: __spreadArray(__spreadArray([], (((_a = newConfig.commonOptions) === null || _a === void 0 ? void 0 : _a.plugins) || []), true), (((_b = newConfig.options[target]) === null || _b === void 0 ? void 0 : _b.plugins) || []), true) });
        }
    }
    return newConfig;
};
function clean(options, target) {
    return __awaiter(this, void 0, void 0, function () {
        var outputPattern, oldFiles, newFilenames;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    outputPattern = "".concat(options.dest, "/").concat(options.getTargetPath({ target: target }), "/").concat(options.files);
                    oldFiles = (0, files_1.getFiles)({ files: outputPattern, exclude: options.exclude });
                    newFilenames = (0, files_1.getFiles)({ files: options.files, exclude: options.exclude })
                        .map(function (path) {
                        return (0, mitosis_1.checkIsMitosisComponentFilePath)(path)
                            ? (0, mitosis_1.renameComponentFile)({ target: target, path: path, options: options })
                            : path.endsWith('.js') || path.endsWith('.ts')
                                ? getNonComponentOutputFileName({ target: target, path: path, options: options })
                                : undefined;
                    })
                        .filter(function (x) { return Boolean(x); });
                    return [4 /*yield*/, Promise.all(oldFiles.map(function (oldFile) { return __awaiter(_this, void 0, void 0, function () {
                            var fileExists;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        fileExists = newFilenames.some(function (newFile) { return oldFile.endsWith(newFile); });
                                        if (!!fileExists) return [3 /*break*/, 2];
                                        return [4 /*yield*/, (0, fs_extra_1.remove)(oldFile)];
                                    case 1:
                                        _a.sent();
                                        _a.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
var getRequiredParsers = function (options) {
    var targetsOptions = Object.values(options.options);
    var targetsRequiringTypeScript = targetsOptions.filter(function (option) { return option.typescript; }).length;
    var needsTypeScript = targetsRequiringTypeScript > 0;
    /**
     * We use 2 ways to check if the user requires a JS output:
     * - either there are fewer `options[target].typescript === true` than there are items in `targets`
     * - either there are fewer `options[target].typescript === true` than there are items in `options.options`
     *
     * The reason for checking in multiple ways is if there is a mismatch between the number of targets in the `targets`
     * array compared to the configurations in `options.options`.
     */
    var needsJavaScript = options.targets.length > targetsRequiringTypeScript ||
        targetsOptions.length > targetsRequiringTypeScript;
    return {
        typescript: needsTypeScript,
        javascript: needsJavaScript,
    };
};
var parseJsxComponent = function (_a) {
    var options = _a.options, path = _a.path, file = _a.file, tsProject = _a.tsProject;
    return __awaiter(void 0, void 0, void 0, function () {
        var requiredParses, typescriptMitosisJson, javascriptMitosisJson, jsxArgs, _b, _c, singleParse, _d, output;
        var _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    requiredParses = getRequiredParsers(options);
                    jsxArgs = __assign(__assign({}, (_e = options.parserOptions) === null || _e === void 0 ? void 0 : _e.jsx), { tsProject: tsProject, filePath: path, typescript: false });
                    if (!(requiredParses.typescript && requiredParses.javascript)) return [3 /*break*/, 7];
                    if (!options.parser) return [3 /*break*/, 2];
                    return [4 /*yield*/, options.parser(file, path)];
                case 1:
                    _b = _f.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _b = (0, mitosis_1.parseJsx)(file, __assign(__assign({}, jsxArgs), { typescript: true }));
                    _f.label = 3;
                case 3:
                    typescriptMitosisJson = _b;
                    if (!options.parser) return [3 /*break*/, 5];
                    return [4 /*yield*/, options.parser(file, path)];
                case 4:
                    _c = _f.sent();
                    return [3 /*break*/, 6];
                case 5:
                    _c = (0, mitosis_1.parseJsx)(file, __assign(__assign({}, jsxArgs), { typescript: false }));
                    _f.label = 6;
                case 6:
                    javascriptMitosisJson = _c;
                    return [3 /*break*/, 11];
                case 7:
                    if (!options.parser) return [3 /*break*/, 9];
                    return [4 /*yield*/, options.parser(file, path)];
                case 8:
                    _d = _f.sent();
                    return [3 /*break*/, 10];
                case 9:
                    _d = (0, mitosis_1.parseJsx)(file, __assign(__assign({}, jsxArgs), { typescript: requiredParses.typescript }));
                    _f.label = 10;
                case 10:
                    singleParse = _d;
                    // technically only one of these will be used, but we set both to simplify things types-wise.
                    typescriptMitosisJson = singleParse;
                    javascriptMitosisJson = singleParse;
                    _f.label = 11;
                case 11:
                    output = {
                        path: path,
                        typescriptMitosisJson: typescriptMitosisJson,
                        javascriptMitosisJson: javascriptMitosisJson,
                    };
                    return [2 /*return*/, output];
            }
        });
    });
};
var parseSvelteComponent = function (_a) {
    var path = _a.path, file = _a.file;
    return __awaiter(void 0, void 0, void 0, function () {
        var json, output;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, (0, mitosis_1.parseSvelte)(file, path)];
                case 1:
                    json = _b.sent();
                    output = {
                        path: path,
                        typescriptMitosisJson: json,
                        javascriptMitosisJson: json,
                    };
                    return [2 /*return*/, output];
            }
        });
    });
};
var findTsConfigFile = function (options) {
    var _a, _b;
    var optionPath = (_b = (_a = options.parserOptions) === null || _a === void 0 ? void 0 : _a.jsx) === null || _b === void 0 ? void 0 : _b.tsConfigFilePath;
    if (optionPath && (0, fs_extra_1.pathExistsSync)(optionPath)) {
        return optionPath;
    }
    var defaultPath = [cwd, 'tsconfig.json'].join('/');
    if ((0, fs_extra_1.pathExistsSync)(defaultPath)) {
        return defaultPath;
    }
    return undefined;
};
var getMitosisComponentJSONs = function (options) { return __awaiter(void 0, void 0, void 0, function () {
    var paths, tsConfigFilePath, tsProject;
    return __generator(this, function (_a) {
        paths = (0, files_1.getFiles)({ files: options.files, exclude: options.exclude }).filter(mitosis_1.checkIsMitosisComponentFilePath);
        tsConfigFilePath = findTsConfigFile(options);
        tsProject = tsConfigFilePath ? (0, mitosis_1.createTypescriptProject)(tsConfigFilePath) : undefined;
        return [2 /*return*/, Promise.all(paths.map(function (path) { return __awaiter(void 0, void 0, void 0, function () {
                var file, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 6, , 7]);
                            return [4 /*yield*/, (0, fs_extra_1.readFile)(path, 'utf8')];
                        case 1:
                            file = _a.sent();
                            if (!(0, mitosis_1.checkIsSvelteComponentFilePath)(path)) return [3 /*break*/, 3];
                            return [4 /*yield*/, parseSvelteComponent({ path: path, file: file })];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3: return [4 /*yield*/, parseJsxComponent({ options: options, path: path, file: file, tsProject: tsProject })];
                        case 4: return [2 /*return*/, _a.sent()];
                        case 5: return [3 /*break*/, 7];
                        case 6:
                            err_1 = _a.sent();
                            console.error('Could not parse file:', path);
                            throw err_1;
                        case 7: return [2 /*return*/];
                    }
                });
            }); }))];
    });
}); };
var getTargetContexts = function (options) {
    return options.targets.map(function (target) {
        var _a;
        return ({
            target: target,
            generator: (_a = options.generators) === null || _a === void 0 ? void 0 : _a[target],
            outputPath: options.getTargetPath({ target: target }),
        });
    });
};
var buildAndOutputNonComponentFiles = function (targetContext) { return __awaiter(void 0, void 0, void 0, function () {
    var files;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, buildNonComponentFiles(targetContext)];
            case 1:
                files = _a.sent();
                return [4 /*yield*/, outputNonComponentFiles(__assign(__assign({}, targetContext), { files: files }))];
            case 2: return [2 /*return*/, _a.sent()];
        }
    });
}); };
function build(config) {
    return __awaiter(this, void 0, void 0, function () {
        var options, mitosisComponents, targetContexts;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    options = getOptions(config);
                    return [4 /*yield*/, getMitosisComponentJSONs(options)];
                case 1:
                    mitosisComponents = _a.sent();
                    targetContexts = getTargetContexts(options);
                    return [4 /*yield*/, Promise.all(targetContexts.map(function (targetContext) { return __awaiter(_this, void 0, void 0, function () {
                            var files, x;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: 
                                    // clean output directory
                                    return [4 /*yield*/, clean(options, targetContext.target)];
                                    case 1:
                                        // clean output directory
                                        _a.sent();
                                        files = (0, fast_clone_1.fastClone)(mitosisComponents);
                                        return [4 /*yield*/, Promise.all([
                                                buildAndOutputNonComponentFiles(__assign(__assign({}, targetContext), { options: options })),
                                                buildAndOutputComponentFiles(__assign(__assign({}, targetContext), { options: options, files: files })),
                                            ])];
                                    case 2:
                                        x = _a.sent();
                                        console.info("Mitosis: ".concat(targetContext.target, ": generated ").concat(x[1].length, " components, ").concat(x[0].length, " regular files."));
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    _a.sent();
                    console.info('Mitosis: generation completed.');
                    return [2 /*return*/];
            }
        });
    });
}
exports.build = build;
/**
 * Transpiles and outputs Mitosis component files.
 */
function buildAndOutputComponentFiles(_a) {
    var target = _a.target, files = _a.files, options = _a.options, generator = _a.generator, outputPath = _a.outputPath;
    return __awaiter(this, void 0, void 0, function () {
        var debugTarget, shouldOutputTypescript, output;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    debugTarget = (0, debug_1.default)("mitosis:".concat(target));
                    shouldOutputTypescript = (0, mitosis_1.checkShouldOutputTypeScript)({ options: options, target: target });
                    output = files.map(function (_a) {
                        var path = _a.path, typescriptMitosisJson = _a.typescriptMitosisJson, javascriptMitosisJson = _a.javascriptMitosisJson;
                        return __awaiter(_this, void 0, void 0, function () {
                            var outputFilePath, overrideFilePath, overrideFile, transpiled, component, outputDir;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        outputFilePath = (0, mitosis_1.renameComponentFile)({ target: target, path: path, options: options });
                                        overrideFilePath = "".concat(options.overridesDir, "/").concat(getTargetPath({ target: target }));
                                        return [4 /*yield*/, (0, overrides_1.getOverrideFile)({
                                                filename: outputFilePath,
                                                path: overrideFilePath,
                                                target: target,
                                            })];
                                    case 1:
                                        overrideFile = _b.sent();
                                        debugTarget("transpiling ".concat(path, "..."));
                                        transpiled = '';
                                        if (overrideFile) {
                                            debugTarget("override exists for ".concat(path, ": ").concat(!!overrideFile));
                                        }
                                        try {
                                            component = shouldOutputTypescript ? typescriptMitosisJson : javascriptMitosisJson;
                                            transpiled = overrideFile !== null && overrideFile !== void 0 ? overrideFile : generator(options.options[target])({ path: path, component: component });
                                            debugTarget("Success: transpiled ".concat(path, ". Output length: ").concat(transpiled.length));
                                        }
                                        catch (error) {
                                            debugTarget("Failure: transpiled ".concat(path, "."));
                                            debugTarget(error);
                                            throw error;
                                        }
                                        transpiled = (0, transpile_1.transformImports)({ target: target, options: options })(transpiled);
                                        outputDir = "".concat(options.dest, "/").concat(outputPath);
                                        return [4 /*yield*/, (0, fs_extra_1.outputFile)("".concat(outputDir, "/").concat(outputFilePath), transpiled)];
                                    case 2:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                    return [4 /*yield*/, Promise.all(output)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
}
var getNonComponentFileExtension = (0, function_1.flow)(mitosis_1.checkShouldOutputTypeScript, function (shouldOutputTypeScript) {
    return shouldOutputTypeScript ? '.ts' : '.js';
});
var getNonComponentOutputFileName = function (_a) {
    var target = _a.target, options = _a.options, path = _a.path;
    return path.replace(/\.tsx?$/, getNonComponentFileExtension({ target: target, options: options }));
};
/**
 * Outputs non-component files to the destination directory, without modifying them.
 */
var outputNonComponentFiles = function (_a) {
    var files = _a.files, options = _a.options, outputPath = _a.outputPath, target = _a.target;
    return __awaiter(void 0, void 0, void 0, function () {
        var folderPath;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    folderPath = "".concat(options.dest, "/").concat(outputPath);
                    return [4 /*yield*/, Promise.all(files.map(function (_a) {
                            var path = _a.path, output = _a.output;
                            return (0, fs_extra_1.outputFile)("".concat(folderPath, "/").concat(getNonComponentOutputFileName({ options: options, path: path, target: target })), output);
                        }))];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
};
function buildContextFile(_a) {
    var target = _a.target, options = _a.options, path = _a.path;
    return __awaiter(this, void 0, void 0, function () {
        var output;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, (0, context_1.generateContextFile)({ path: path, options: options, target: target })];
                case 1:
                    output = (_b.sent()) || '';
                    if (!!(0, mitosis_1.checkShouldOutputTypeScript)({ target: target, options: options })) return [3 /*break*/, 3];
                    return [4 /*yield*/, (0, transpile_1.transpile)({
                            path: path,
                            target: target,
                            content: output,
                            options: options,
                        })];
                case 2:
                    output = _b.sent();
                    _b.label = 3;
                case 3:
                    // we remove the `.lite` extension from the path for Context files.
                    path = path.replace('.lite.ts', '.ts');
                    return [2 /*return*/, {
                            path: path,
                            output: output,
                        }];
            }
        });
    });
}
/**
 * Transpiles all non-component files, including Context files.
 */
function buildNonComponentFiles(args) {
    return __awaiter(this, void 0, void 0, function () {
        var target, options, nonComponentFiles;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    target = args.target, options = args.options;
                    nonComponentFiles = (0, files_1.getFiles)({ files: options.files, exclude: options.exclude }).filter(function (file) { return file.endsWith('.ts') || file.endsWith('.js'); });
                    return [4 /*yield*/, Promise.all(nonComponentFiles.map(function (path) { return __awaiter(_this, void 0, void 0, function () {
                            var overrideFilePath, overrideFile, _a, output_1, _b, isContextFile, file, output, _c;
                            return __generator(this, function (_d) {
                                switch (_d.label) {
                                    case 0:
                                        overrideFilePath = "".concat(options.overridesDir, "/").concat(getTargetPath({ target: target }), "/").concat(path);
                                        return [4 /*yield*/, (0, fs_extra_1.pathExists)(overrideFilePath)];
                                    case 1:
                                        if (!(_d.sent())) return [3 /*break*/, 3];
                                        return [4 /*yield*/, (0, fs_extra_1.readFile)(overrideFilePath, 'utf8')];
                                    case 2:
                                        _a = _d.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        _a = null;
                                        _d.label = 4;
                                    case 4:
                                        overrideFile = _a;
                                        if (!overrideFile) return [3 /*break*/, 6];
                                        _b = function_1.pipe;
                                        return [4 /*yield*/, (0, transpile_1.transpileIfNecessary)({ path: path, target: target, content: overrideFile, options: options })];
                                    case 5:
                                        output_1 = _b.apply(void 0, [_d.sent(), (0, transpile_1.transformImports)({ target: target, options: options })]);
                                        return [2 /*return*/, { output: output_1, path: path }];
                                    case 6:
                                        isContextFile = path.endsWith('.context.lite.ts');
                                        if (isContextFile) {
                                            return [2 /*return*/, buildContextFile(__assign(__assign({}, args), { path: path }))];
                                        }
                                        return [4 /*yield*/, (0, fs_extra_1.readFile)(path, 'utf8')];
                                    case 7:
                                        file = _d.sent();
                                        _c = function_1.pipe;
                                        return [4 /*yield*/, (0, transpile_1.transpileIfNecessary)({ path: path, target: target, options: options, content: file })];
                                    case 8:
                                        output = _c.apply(void 0, [_d.sent(), (0, transpile_1.transformImports)({ target: target, options: options }),
                                            function (code) { return (0, mitosis_1.mapSignalTypeInTSFile)({ code: code, target: target }); },
                                            mitosis_1.removeMitosisImport]);
                                        return [2 /*return*/, { output: output, path: path }];
                                }
                            });
                        }); }))];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
if (require.main === module) {
    build().catch(console.error);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYnVpbGQvYnVpbGQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQ0FnQjZCO0FBQzdCLGdEQUEwQjtBQUMxQiwrQ0FBZ0Q7QUFDaEQscUNBQW9GO0FBQ3BGLGlDQUFtQztBQUNuQyxvREFBa0Q7QUFDbEQsNkNBQXdEO0FBQ3hELHlDQUEyQztBQUMzQyxpREFBc0Q7QUFDdEQsaURBQXdGO0FBRXhGLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUUxQjs7R0FFRztBQUNILElBQU0sYUFBYSxHQUFHLFVBQUMsRUFBOEI7UUFBNUIsTUFBTSxZQUFBO0lBQzdCLFFBQVEsTUFBTSxFQUFFLENBQUM7UUFDZjtZQUNFLE9BQU8sSUFBQSxrQkFBUyxFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRixJQUFNLGNBQWMsR0FBRztJQUNyQixPQUFPLEVBQUUsRUFBRTtJQUNYLElBQUksRUFBRSxRQUFRO0lBQ2QsS0FBSyxFQUFFLE9BQU87SUFDZCxZQUFZLEVBQUUsV0FBVztJQUN6QixhQUFhLGVBQUE7SUFDYixPQUFPLEVBQUUsRUFBRTtDQUNxQixDQUFDO0FBRW5DLElBQU0sVUFBVSxHQUFHLFVBQUMsTUFBc0I7O0lBQ3hDLElBQU0sU0FBUyxrQ0FDVixjQUFjLEdBQ2QsTUFBTSxLQUNULE9BQU8sd0JBQ0YsY0FBYyxDQUFDLE9BQU8sR0FDdEIsTUFBTSxhQUFOLE1BQU0sdUJBQU4sTUFBTSxDQUFFLE9BQU8sR0FFcEIsVUFBVSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsaUJBQU8sRUFBRSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsVUFBVSxDQUFDLEdBQ3ZELENBQUM7SUFFRjs7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