"use strict";
exports.__esModule = true;
var types = require("@babel/types");
var isMitosisPath_1 = require("../helpers/isMitosisPath");
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
var rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'disallow using ref.current',
            recommended: true
        }
    },
    create: function (context) {
        // variables should be defined here
        var filename = context.getFilename();
        if (!(0, isMitosisPath_1["default"])(filename))
            return {};
        // ----------------------------------------------------------------------
        // Helpers
        // ----------------------------------------------------------------------
        // any helper functions should go here or else delete this section
        // ----------------------------------------------------------------------
        // Public
        // ----------------------------------------------------------------------
        //
        var listener = {
            MemberExpression: function (node) {
                if (types.isIdentifier(node.property) && node.property.name === 'current') {
                    if (types.isIdentifier(node.object)) {
                        var name_1 = node.object.name;
                        var program = context.getAncestors()[0];
                        if (!types.isProgram(program))
                            return;
                        var importSpecifiers = program.body.find(function (n) { return types.isImportDeclaration(n); });
                        if (!types.isImportDeclaration(importSpecifiers))
                            return;
                        var useRef = importSpecifiers.specifiers.find(function (n) {
                            if (types.isImportSpecifier(n) && n.imported.name === 'useRef') {
                                return true;
                            }
                        });
                        if (!useRef)
                            return;
                        var useRefHookLocalName = useRef === null || useRef === void 0 ? void 0 : useRef.local.name;
                        var component = program.body.find(function (n) { return types.isExportDefaultDeclaration(n); });
                        if (!types.isExportDefaultDeclaration(component))
                            return;
                        if (!types.isFunctionDeclaration(component.declaration) &&
                            !types.isArrowFunctionExpression(component.declaration))
                            return;
                        if (!types.isBlock(component.declaration.body))
                            return;
                        var componentBody = component.declaration.body.body;
                        for (var _i = 0, componentBody_1 = componentBody; _i < componentBody_1.length; _i++) {
                            var n = componentBody_1[_i];
                            if (!types.isVariableDeclaration(n))
                                continue;
                            for (var _a = 0, _b = n.declarations; _a < _b.length; _a++) {
                                var d = _b[_a];
                                if (!types.isVariableDeclarator(d) ||
                                    !types.isIdentifier(d.id) ||
                                    d.id.name !== name_1 ||
                                    !types.isCallExpression(d.init) ||
                                    !types.isIdentifier(d.init.callee) ||
                                    d.init.callee.name !== useRefHookLocalName)
                                    continue;
                                context.report({
                                    node: node,
                                    message: "property \"current\" doesn't exists on refs. you can call methods directly on them e.g: ".concat(name_1, ".focus(), or assign them a value e.g: ").concat(name_1, " = 1;")
                                });
                            }
                        }
                    }
                }
            }
        };
        return listener;
    }
};
exports["default"] = rule;
