"use strict";
exports.__esModule = true;
var types = require("@babel/types");
var ts_pattern_1 = require("ts-pattern");
var isMitosisPath_1 = require("../helpers/isMitosisPath");
var noOp_1 = require("../helpers/noOp");
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
var rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'disallow naming the event arg for callbacks anything other than "event".',
            recommended: true
        },
        fixable: 'code',
        schema: [
            {},
            // fill in your schema
        ]
    },
    create: function (context) {
        // variables should be defined here
        var filename = context.getFilename();
        if (!(0, isMitosisPath_1["default"])(filename))
            return {};
        // ----------------------------------------------------------------------
        // Helpers
        // ----------------------------------------------------------------------
        // any helper functions should go here or else delete this section
        // ----------------------------------------------------------------------
        // Public
        // ----------------------------------------------------------------------
        //
        var listener = {
            JSXExpressionContainer: function (node) {
                (0, ts_pattern_1.match)(node)["with"]({ expression: { params: [] } }, noOp_1["default"])["with"]({ expression: (0, ts_pattern_1.not)((0, ts_pattern_1.when)(types.isFunction)) }, noOp_1["default"])["with"]({
                    parent: (0, ts_pattern_1.when)(types.isJSXAttribute),
                    expression: {
                        // WARN: This is a list, not a 1-length tuple, this might not
                        // work on cases that have multiple args - I don't know if there
                        // is anything in the web api that expects multiple args for the
                        // callback.
                        params: [{ type: 'Identifier', name: (0, ts_pattern_1.not)('event') }]
                    }
                }, function (_a) {
                    var arg1 = _a.expression.params[0];
                    context.report({
                        node: arg1,
                        message: 'Callback parameter must be called `event`',
                        fix: function (fixer) {
                            return fixer.replaceText(arg1, 'event');
                        }
                    });
                })
                    .otherwise(noOp_1["default"]);
            }
        };
        return listener;
    }
};
exports["default"] = rule;
