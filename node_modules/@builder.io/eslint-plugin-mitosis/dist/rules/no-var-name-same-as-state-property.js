"use strict";
exports.__esModule = true;
var types = require("@babel/types");
var hooks_1 = require("../constants/hooks");
var isMitosisPath_1 = require("../helpers/isMitosisPath");
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
var rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'disallow defining variables with the same name as a state property',
            recommended: true
        }
    },
    create: function (context) {
        // variables should be defined here
        var filename = context.getFilename();
        if (!(0, isMitosisPath_1["default"])(filename))
            return {};
        // ----------------------------------------------------------------------
        // Helpers
        // ----------------------------------------------------------------------
        // any helper functions should go here or else delete this section
        // ----------------------------------------------------------------------
        // Public
        // ----------------------------------------------------------------------
        //
        var listener = {
            CallExpression: function (node) {
                var program = context.getAncestors()[0];
                if (!types.isProgram(program))
                    return;
                var importSpecifiers = program.body.find(function (n) { return types.isImportDeclaration(n); });
                if (!types.isImportDeclaration(importSpecifiers))
                    return;
                var useState = importSpecifiers.specifiers.find(function (n) {
                    if (types.isImportSpecifier(n) &&
                        (n.imported.name === hooks_1.HOOKS.STATE || n.imported.name === hooks_1.HOOKS.STORE)) {
                        return true;
                    }
                });
                if (!useState || !types.isIdentifier(node.callee))
                    return;
                var useStateHookLocalName = useState === null || useState === void 0 ? void 0 : useState.local.name;
                if (node.callee.name !== useStateHookLocalName ||
                    !types.isObjectExpression(node.arguments[0]))
                    return;
                var component = program.body.find(function (n) { return types.isExportDefaultDeclaration(n); });
                if (!types.isExportDefaultDeclaration(component))
                    return;
                if (!types.isFunctionDeclaration(component.declaration) &&
                    !types.isArrowFunctionExpression(component.declaration))
                    return;
                if (!types.isBlock(component.declaration.body))
                    return;
                var componentBody = component.declaration.body.body;
                var _loop_1 = function (prop) {
                    if (!types.isProperty(prop) || !types.isIdentifier(prop.key))
                        return "continue";
                    if (types.isFunctionExpression(prop.value)) {
                        var body = prop.value.body.body;
                        var params = prop.value.params;
                        var _loop_2 = function (prop_1) {
                            if (!types.isProperty(prop_1) || !types.isIdentifier(prop_1.key))
                                return "continue";
                            var name_1 = prop_1.key.name;
                            params.forEach(function (p) {
                                if (types.isIdentifier(p) && p.name === name_1) {
                                    context.report({
                                        node: prop_1,
                                        message: 'variables with the same name as a state property will shadow it'
                                    });
                                }
                            });
                        };
                        for (var _b = 0, _c = node.arguments[0].properties; _b < _c.length; _b++) {
                            var prop_1 = _c[_b];
                            _loop_2(prop_1);
                        }
                        var varDeclarators_2 = [];
                        var functionDeclarations_2 = [];
                        body.forEach(function (n) {
                            if (types.isVariableDeclaration(n)) {
                                varDeclarators_2.push.apply(varDeclarators_2, n.declarations);
                            }
                            else if (types.isFunctionDeclaration(n)) {
                                functionDeclarations_2.push(n);
                            }
                        });
                        if (!varDeclarators_2.length && !functionDeclarations_2.length)
                            return "continue";
                        for (var _d = 0, functionDeclarations_1 = functionDeclarations_2; _d < functionDeclarations_1.length; _d++) {
                            var d = functionDeclarations_1[_d];
                            for (var _e = 0, _f = d.params; _e < _f.length; _e++) {
                                var p = _f[_e];
                                if (!types.isIdentifier(p))
                                    continue;
                                for (var _g = 0, _h = node.arguments[0].properties; _g < _h.length; _g++) {
                                    var prop_2 = _h[_g];
                                    if (!types.isProperty(prop_2) || !types.isIdentifier(prop_2.key))
                                        continue;
                                    var name_2 = prop_2.key.name;
                                    if (p.name === name_2) {
                                        context.report({
                                            node: prop_2,
                                            message: 'variables with the same name as a state property will shadow it'
                                        });
                                    }
                                }
                            }
                        }
                        for (var _j = 0, varDeclarators_1 = varDeclarators_2; _j < varDeclarators_1.length; _j++) {
                            var d = varDeclarators_1[_j];
                            var _loop_3 = function (prop_3) {
                                if (!types.isProperty(prop_3) || !types.isIdentifier(prop_3.key))
                                    return "continue";
                                var name_3 = prop_3.key.name;
                                if (!types.isIdentifier(d.id))
                                    return "continue";
                                if (d.id.name === name_3) {
                                    context.report({
                                        node: prop_3,
                                        message: 'variables with the same name as a state property will shadow it'
                                    });
                                }
                                else if (types.isArrowFunctionExpression(d.init) ||
                                    types.isFunctionExpression(d.init)) {
                                    var params_1 = d.init.params;
                                    params_1.forEach(function (p) {
                                        if (types.isIdentifier(p) && p.name === name_3) {
                                            context.report({
                                                node: prop_3,
                                                message: 'variables with the same name as a state property will shadow it'
                                            });
                                        }
                                    });
                                }
                            };
                            for (var _k = 0, _l = node.arguments[0].properties; _k < _l.length; _k++) {
                                var prop_3 = _l[_k];
                                _loop_3(prop_3);
                            }
                        }
                    }
                    else {
                        var name_4 = prop.key.name;
                        var _loop_4 = function (n) {
                            if (types.isVariableDeclaration(n)) {
                                for (var _o = 0, _p = n.declarations; _o < _p.length; _o++) {
                                    var d = _p[_o];
                                    if (!types.isVariableDeclarator(d) ||
                                        !types.isIdentifier(d.id) ||
                                        d.id.name !== name_4)
                                        continue;
                                    context.report({
                                        node: d,
                                        message: 'variables with the same name as a state property will shadow it'
                                    });
                                }
                            }
                            else if (types.isFunctionDeclaration(n)) {
                                var body = n.body.body;
                                var varDeclarators_4 = [];
                                body.forEach(function (n) {
                                    if (types.isVariableDeclaration(n)) {
                                        varDeclarators_4.push.apply(varDeclarators_4, n.declarations);
                                    }
                                });
                                for (var _q = 0, varDeclarators_3 = varDeclarators_4; _q < varDeclarators_3.length; _q++) {
                                    var d = varDeclarators_3[_q];
                                    if (!types.isIdentifier(d.id) && !types.isObjectPattern(d.id))
                                        continue;
                                    if (types.isObjectPattern(d.id)) {
                                        for (var _r = 0, _s = d.id.properties; _r < _s.length; _r++) {
                                            var p = _s[_r];
                                            if (types.isProperty(p) &&
                                                types.isIdentifier(p.value) &&
                                                p.value.name == name_4) {
                                                context.report({
                                                    node: prop,
                                                    message: 'variables with the same name as a state property will shadow it'
                                                });
                                            }
                                        }
                                    }
                                    else if (d.id.name === name_4) {
                                        context.report({
                                            node: prop,
                                            message: 'variables with the same name as a state property will shadow it'
                                        });
                                    }
                                }
                            }
                        };
                        for (var _m = 0, componentBody_1 = componentBody; _m < componentBody_1.length; _m++) {
                            var n = componentBody_1[_m];
                            _loop_4(n);
                        }
                    }
                };
                for (var _i = 0, _a = node.arguments[0].properties; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    _loop_1(prop);
                }
            }
        };
        return listener;
    }
};
exports["default"] = rule;
