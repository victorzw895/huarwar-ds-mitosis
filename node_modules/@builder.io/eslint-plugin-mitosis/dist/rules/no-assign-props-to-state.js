"use strict";
exports.__esModule = true;
var types = require("@babel/types");
var hooks_1 = require("../constants/hooks");
var isMitosisPath_1 = require("../helpers/isMitosisPath");
// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
var rule = {
    meta: {
        type: 'problem',
        docs: {
            description: 'disallow assigning props to state',
            recommended: true
        }
    },
    create: function (context) {
        // variables should be defined here
        var filename = context.getFilename();
        if (!(0, isMitosisPath_1["default"])(filename))
            return {};
        // ----------------------------------------------------------------------
        // Helpers
        // ----------------------------------------------------------------------
        // any helper functions should go here or else delete this section
        // ----------------------------------------------------------------------
        // Public
        // ----------------------------------------------------------------------
        //
        var listener = {
            CallExpression: function (node) {
                var program = context.getAncestors()[0];
                if (!types.isProgram(program))
                    return;
                var importSpecifiers = program.body.find(function (n) { return types.isImportDeclaration(n); });
                if (!types.isImportDeclaration(importSpecifiers))
                    return;
                var useState = importSpecifiers.specifiers.find(function (n) {
                    if (types.isImportSpecifier(n) &&
                        (n.imported.name === hooks_1.HOOKS.STATE || n.imported.name === hooks_1.HOOKS.STORE)) {
                        return true;
                    }
                });
                if (!types.isImportSpecifier(useState))
                    return;
                if (!types.isIdentifier(node.callee))
                    return;
                if (node.callee.name !== useState.imported.name)
                    return;
                if (!useState ||
                    !types.isIdentifier(node.callee) ||
                    !types.isObjectExpression(node.arguments[0]))
                    return;
                var component = program.body.find(function (n) { return types.isExportDefaultDeclaration(n); });
                if (!types.isExportDefaultDeclaration(component))
                    return;
                if (!types.isFunctionDeclaration(component.declaration) &&
                    !types.isArrowFunctionExpression(component.declaration))
                    return;
                var params = component.declaration.params;
                if (!types.isIdentifier(params[0]))
                    return;
                var name = params[0].name;
                for (var _i = 0, _a = node.arguments[0].properties; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (!types.isProperty(prop))
                        return;
                    var object = prop.value.object;
                    if (!types.isIdentifier(object))
                        return;
                    if (object.name === name) {
                        context.report({
                            node: prop,
                            message: '"props" can\'t be assign to  to "state" directly'
                        });
                    }
                }
            }
        };
        return listener;
    }
};
exports["default"] = rule;
